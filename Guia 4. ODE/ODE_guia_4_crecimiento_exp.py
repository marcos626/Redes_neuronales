"""redes-neuronales-2024-guia-4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/marcos626/f1994542d9280d4a2d6b234aebbdf230/redes-neuronales-2024-guia-4.ipynb

# Integración numérica de ODEs

En este práctico introduciremos los métodos de **Euler** y de **RK4** (Runge-Kutta de orden 4) de integración numérica de Ecuaciones Diferenciales Ordinarias (ODEs).

## **Ejercicio 1)** Importando librerías

Importe las librerías `numpy` para operar con arrays, `scipy` para utilizar rutinas de algebra lineal y `matplotlib.pyplot` para graficar.
"""

import numpy as np
import scipy as sp
import scipy.linalg as linalg
import matplotlib.pyplot as plt


### Ecuaciones Diferenciales Ordinarias (ODEs)
# 2.1)
def euler(f,x,t,h,p):
    """
    Calcula un paso de integración del método de Euler.

    Argumentos de entrada:

        f : R^n,R -> R^n
        x = x(t) : R^n
        t = tiempo : R
        h = paso de tiempo : R
        p = parametros : R^q

    Retorna aproximacion numérica de

        x(t+h) : R^n

    según el método de Euler.

    # Ejemplos:
    """
    return x+h*f(x,t,p)

# 2.2)
def integrador_ode(m,f,xa,a,b,k,p,c=lambda x,t,p:x):
    """
    Integra numéricamente la ODE

        dx/dt = f(x,t)

    sobre el intervalo t:[a,b] usando k pasos de integración y el método m, bajo condicion inicial x(a)=x0.
    No es necesario que a<b.

    Argumentos de entrada:

        m = metodo de integracion (ej. euler, rk2, etc.)
        f : R^n -> R^n
        xa = condicion inicial : R
        a = tiempo inicial : R
        b = tiempo final : R
        k = num. pasos de integracion : N
        p = parametros : R^q
        c = función condicionante : R^n,R,p -> R^n

    Retorna:

        t : R^{k+1} , t_j = a+j*h para j=0,1,...,k
        w : R^{n,k+1} , w_ij = x_i(t_j) para i=0,1,...,n-1 y j=0,1,...,k

    donde a+k*dt = b.
    """
    assert k>0
    n = len(xa)
    h = (b-a)/k
    w = np.zeros((n,k+1)) # Produce un array con forma y tipo especificada con los parametros,
                          # lleno de ceros. la forma puede ser espcificada con un entero o tupla (n,k+1)
    t = np.zeros(k+1)
    w[:,0] = xa           # actualiza la posicion inicial (columna de indice 0) de las variables con los valores
                          # de las condiciones iniciales
    t[0] = a              # actualiza la posicion cero con el valor del tiempo inicial

    for j in range(k):    #Aca se produce la iteración en j

        t[j+1] = t[j] + h                # iteracion tiempo
        w[:,j+1] = m(f,w[:,j],t[j],h,p)  # iteracion de w
        w[:,j+1] = c(w[:,j+1],t[j+1],p)  # condicion sobre w

    return t,w




## **Ejercicio 3)** Crecimiento exponencial
#3.1)
def f(x,t,p):
    """
    q = p[0]
    """
    return p[0]*np.array(x[0])


a=0
b=3
h=0.1
k = int((b-a)/h)#+1
xa = np.array([1]) # x(a)=x(0)=1
p = np.array([1])
t,w = integrador_ode(euler,f,xa,a,b,k,p)

# 3.2)
plt.xlabel('$t$')
plt.ylabel('$x(t)$')
#plt.xlim(-0.1,5.1)
#plt.ylim(-0.1,1.1)
print(t)
print()
print(w[0,:])
plt.scatter(t,w[0,:],label="numérica",linestyle='-',c='red')
plt.plot(t,np.exp(p[0]*t),label="exacta",linestyle='-',c='blue')
plt.title('Crecimiento exponencial, Euler, $h=0.1$')
plt.legend()



"""
# 3.3)
h=0.01
k = int((b-a)/h)#+1
t,w = integrador_ode(euler,f,xa,a,b,k,p)

plt.xlabel('$t$')
plt.ylabel('$x(t)$')
#plt.xlim(-0.1,5.1)
#plt.ylim(-0.1,1.1)
plt.scatter(t,w[0,:],label="numérica",linestyle='-',c='red')
plt.plot(t,np.exp(p[0]*t),label="exacta",linestyle='-',c='blue')
plt.title('Crecimiento exponencial, Euler, $h=0.01$')
plt.legend()

"""